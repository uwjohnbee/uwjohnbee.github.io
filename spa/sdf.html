<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="TASKAR Center for Accessible Technology - AVIV ScoutRoute Feedback">
        <title>AVIV ScoutRoute Feedback</title>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css" rel="stylesheet">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">
        <style>
            *, *:before, *:after {
                box-sizing: border-box;
            }
            body,
            .container-fluid {
                font-family: 'Open Sans', sans-serif;
                font-size: 36px;
                background-color: #330872;
                overflow-y: hidden;
            }
            .chat .chat-history {
                padding: 30px 30px 20px;
            }
            .chat .chat-history .message-data {
                margin-bottom: 22px;
                color: white;
            }
            .chat .chat-history .message-data-time {
                padding-left: 6px;
            }
            .chat .chat-history .message-data-name {
                font-weight: bold;
            }
            .chat .chat-history .message {
                padding: 18px 20px;
                line-height: 40px;
                border-radius: 5px;
                margin-bottom: 30px;
                width: 95%;
                position: relative;
                background-color: #e2f2f2;
            }

            .chat .chat-history .message:after {
                content: "";
                position: absolute;
                top: -15px;
                left: 20px;
                border-width: 0 15px 15px;
                border-style: solid;
                border-color: #e2f2f2 transparent;
                display: block;
                width: 0;
            }

            .chat .chat-history .message.alt {
                background-color: #f8f8ea;
            }
            .chat .chat-history .message.alt:after {
                border-color: #f8f8ea transparent;
            }

            .chat .chat-message {
                padding: 30px;
            }

            .chat .comment {
                padding-top: 20px;
                padding-bottom: 20px;
                color: black;
            }
            file-o, .chat .chat-message .fa-file-image-o {
                color: white;
                cursor: pointer;
            }

            .chat-ul li{
                list-style-type: none;
                padding-top: 20px;
                padding-bottom: 20px;
            }

            .align-left {
                text-align: left;
            }

            .align-right {
                text-align: right;
            }

            .float-right {
                float: right;
            }

            .clearfix:after {
                visibility: hidden;
                display: block;
                font-size: 0;
                content: " ";
                clear: both;
                height: 0;
            }

            .up {
                transform: translateY(-100vw);
            }

            .down {
                transform: translateY(0);
                transition: 
                    transform .8s cubic-bezier(0.175, 0.885, 0.32, 1.1);
            }
                
            strong {
                font-weight: 600;
            }

            .img-thumbnail {
                max-height: 500px;
                margin-top: 20px;
            }
        </style>
    </head>
    <body>
        <div id=“feed” class="container-fluid clearfix">
            <div class="chat">   
                <div class="chat-history">
                    <ul class="chat-ul" id="changesetRows">
                        <li>
                            <div class="message-data">
                                <span class="message-data-name">William Langland</span>
                            </div>
                            <div class="message">
                                <div class="comment">Patience is a virtue...</div>
                            </div>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/js/bootstrap.bundle.min.js"></script>
        <script>
            const URL_PARAMS = new URLSearchParams(window.location.search);
            const ENV = URL_PARAMS.get('e') || ''; // default to prod if not passed
            const WORKSPACE_ID = URL_PARAMS.get('w') || 125; // default to SDF if not passed
            const TEST_MODE = URL_PARAMS.get('t') || ''; // default to live mode

            const ENV_URL = (ENV.length > 0) ? '-' + ENV : '';
            const TDEI_API_URL = `https://api${ENV_URL}.tdei.us/api/v1/`;
            const POSM_API_URL = `https://osm.workspaces${ENV_URL}.sidewalks.washington.edu/api/0.6/`;
            const MAX_CHANGESETS = 10;
            const POLL_CHANGESET_SECONDS = 300;
            const POLL_DISPLAY_MESSAGE_SECONDS = 30;

            const TAG_DICT = {
                // 1. Nodes
                //      A. Intersections
                "ext:intersection:well_maintained": "that the intersection [location] [is not] well-maintained.",
                //          No | Yes
                "ext:intersection:visibility_rating": "that the intersection's visibility of pedestrians to drivers [location] is [enum].",
                //          1 = Very Poor | 2 = Poor | 3 = Fair | 4 = Good | 5 = Excellent
                "ext:intersection:safe_and_accessible": "that the intersection [location] [is not] safe and accessible for people with disabilities or mobility aids.",
                //          No | Yes
                "ext:kartaview_url": "that the intersection [location] looks like: [photo]", 
                //          No | Yes, ties to ext:kartaview_url
                //      B. Curbs
                "kerb": "that a curb's type [location] is [value].",
                //          Raised | Ramp | Flush
                "tactile_paving": "that a curb [location] [does not] have tactile paving.",
                //          No | Yes
                "ext:ramp:alignment_with_crossing": "that a ramp [location] is [value] with the direction of the crossing.",
                //          Misaligned | Aligned
                // 2. Ways
                //      A. Footways
                "surface": "that a footway's surface material [location] is [value].",
                //          Concrete | Asphalt | Brick
                "ext:footway:surface:condition": "that a footway's surface condition [location] is [enum].",
                //          1 = Very Poor | 2 = Poor | 3 = Fair | 4 = Good | 5 = Excellent
                "ext:footway:disruptions:count": "that the number of disruptions over 2 inches on a footway [location] is [value].",
                //          0 - 50
                //      B. Sidewalks
                "ext:sidewalk:obstruction": "that a sidewalk [location] [does not] have temporary obstructions.", 
                //          No | Yes
                "surface": "that a sidewalk's surface material [location] is [value].",
                //          Concrete | Asphalt | Brick
                "ext:sidewalk:surface:condition": "that a sidewalk's surface condition [location] is [enum].",
                //          1 = Very Poor | 2 = Poor | 3 = Fair | 4 = Good | 5 = Excellent
                "ext:sidewalk:disruptions:count": "that the number of disruptions over 2 inches on a sidewalk [location] is [value].",
                //          0 - 50
                //      C. Crossings
                "surface": "that a crosswalk's surface material [location] is [value].",
                //          Concrete | Asphalt | Brick
                "ext:crossing:surface:condition": "that a crosswalk's surface condition [location] is [enum].",
                //          1 = Very Poor | 2 = Poor | 3 = Fair | 4 = Good | 5 = Excellent
                "ext:crossing:disruptions:count": "that the number of disruptions over 2 inches at a crosswalk [location] is [value].",
                //          0 - 50
                "crossing:markings": "that a crosswalk [location] [does not] have markings on the roadway.",
                //          No | Yes
                "ext:crossing:markings:condition": "that the condition of the markings [location] is [enum].",
                //          1 = Very Poor | 2 = Poor | 3 = Fair | 4 = Good | 5 = Excellent
                "ext:crossing:signals": "that a crosswalk [location] [does not] have signals for pedestrians.",
                //          No | Yes
                "ext:crossing:signals:button": "that a crosswalk [location] [does not] have a push button for pedestrians.",
                //          No | Yes
                "ext:crossing:signals:sound": "that a crosswalk [location] [does not] have an audible indication for when it is safe to cross.",
                //          No | Yes
                "ext:crossing:signals:vibration": "that a crosswalk [location] [does not] have a vibrating tactile indication for when it is safe to cross.",
                //          No | Yes
                "ext:crossing:signals:arrow": "that a crosswalk [location] [does not] have a tactile arrow for pedestrians.",
                //          No | Yes
                "ext:crossing:signals:arrow:alignment": "that a crosswalk [location] is [value] with the direction of travel.",
                //          Misaligned | Aligned
                "ext:crossing:signals:button:reachable": "that a crosswalk [location] [is not] reachable by people with mobility aids."
                //          No | Yes
            };

            const TEST_XML = [
            `<?xml version="1.0" encoding="UTF-8"?>
            <osmChange version="0.6" generator="CGImap 0.10.0.2507212011 (22 788a64db3727)" copyright="OpenStreetMap and contributors" attribution="http://www.openstreetmap.org/copyright" license="http://opendatacommons.org/licenses/odbl/1-0/">
                <modify>
                    <node id="1883150" visible="true" version="2" changeset="1" timestamp="2025-08-06T00:45:14Z" user="Node of Your Business" uid="8" lat="47.6259971" lon="-122.3384143">
                        <nd ref="6768521"/>
                        <nd ref="6768520"/>
                        <tag k="ext:intersection:visibility" v="2"/>
                    </way>
                </modify>
            </osmChange>`,
            `<?xml version="1.0" encoding="UTF-8"?>
            <osmChange version="0.6" generator="CGImap 0.10.0.2507212011 (22 788a64db3727)" copyright="OpenStreetMap and contributors" attribution="http://www.openstreetmap.org/copyright" license="http://opendatacommons.org/licenses/odbl/1-0/">
                <modify>
                    <way id="1841820" visible="true" version="2" changeset="2" timestamp="2025-08-06T00:45:14Z" user="Ways and Means" uid="8">
                        <nd ref="6605122"/>
                        <nd ref="6605121"/>
                        <tag k="surface" v="brick"/>
                    </way>
                </modify>
            </osmChange>`,
            `<?xml version="1.0" encoding="UTF-8"?>
            <osmChange version="0.6" generator="CGImap 0.10.0.2507212011 (22 788a64db3727)" copyright="OpenStreetMap and contributors" attribution="http://www.openstreetmap.org/copyright" license="http://opendatacommons.org/licenses/odbl/1-0/">
                <modify>
                    <node id="1883150" visible="true" version="2" changeset="3" timestamp="2025-08-06T00:45:14Z" user="Node of Your Business" uid="8" lat="47.6259971" lon="-122.3384143">
                        <nd ref="6768521"/>
                        <nd ref="6768520"/>
                        <tag k="ext:intersection:maintained" v="n"/>
                    </way>
                </modify>
            </osmChange>`,
            `<?xml version="1.0" encoding="UTF-8"?>
            <osmChange version="0.6" generator="CGImap 0.10.0.2507212011 (22 788a64db3727)" copyright="OpenStreetMap and contributors" attribution="http://www.openstreetmap.org/copyright" license="http://opendatacommons.org/licenses/odbl/1-0/">
                <modify>
                    <way id="1841820" visible="true" version="2" changeset="4" timestamp="2025-08-06T00:45:14Z" user="Ways and Means" uid="8">
                        <nd ref="6605122"/>
                        <nd ref="6605121"/>
                        <tag k="ext:crossing:signals:vibration" v="y"/>
                    </way>
                </modify>
            </osmChange>`,
            `<?xml version="1.0" encoding="UTF-8"?>
            <osmChange version="0.6" generator="CGImap 0.10.0.2507212011 (22 788a64db3727)" copyright="OpenStreetMap and contributors" attribution="http://www.openstreetmap.org/copyright" license="http://opendatacommons.org/licenses/odbl/1-0/">
                <modify>
                    <node id="1883150" visible="true" version="2" changeset="3" timestamp="2025-08-06T00:45:14Z" user="Node of Your Business" uid="8" lat="47.6259971" lon="-122.3384143">
                        <nd ref="6768521"/>
                        <nd ref="6768520"/>
                        <tag k=""ext:ramp:alignment_with_crossing" v="misaligned"/>
                    </way>
                </modify>
            </osmChange>`
            ];

            let accessToken = undefined;
            let apikey = undefined;
            let minCreationTime = '2025-08-12';
            let changesetsFifo = [];
            let changesetIndex = 0;

            async function login() {
                const username = prompt('TDEI Username');
                const password = prompt('TDEI Password');
                apikey = prompt('TomTom API Key (optional)');

                const response = await fetch(TDEI_API_URL + 'authenticate', {
                    method: 'POST',
                    body: JSON.stringify({ username, password }),
                    headers: { 'Content-Type': 'application/json' }
                });

                if (! response.ok) {
                    alert('Login failed: ' + response.statusText);
                    return;
                }

                const body = await response.json();
                
                // Currently expires in 24 hours
                if(body)
                    accessToken = body.access_token;

                start();
            }

            async function start() {
                if (!accessToken) { alert('Please log in first.'); return; }

                setInterval(refreshChangesets, POLL_CHANGESET_SECONDS * 1000);
                setInterval(displayNextMessage, POLL_DISPLAY_MESSAGE_SECONDS * 1000);

                await refreshChangesets();
                displayNextMessage();
            }

            async function refreshChangesets() {
                // Fetch the newest changesets from the POSM. This API returns changesets 
                // ordered from newest to oldest by default:
                const params = `?from=${minCreationTime}&limit=${MAX_CHANGESETS}`;

                let response = null;
                try {
                    response = await fetch(POSM_API_URL + 'changesets.json' + params, {
                        headers: {
                        'Authorization': 'Bearer ' + accessToken,
                        'X-Workspace': WORKSPACE_ID
                        }
                    });
                } catch (error) {
                    console.log(error);
                    return;
                }

                const newChangesets = (await response.json()).changesets;
                if (!newChangesets.length) {                 
                    console.log("No changesets found");
                    return; 
                }

                // We'll remember the creation time of the newest changeset so that we can 
                // constrain our next cycle to include only changesets newer than this:
                const newMinCreationTime = new Date(newChangesets[0].created_at);

                newMinCreationTime.setSeconds(newMinCreationTime.getSeconds() + 1);
                minCreationTime = newMinCreationTime.toISOString();

                const oldChangesets = changesetsFifo.splice(MAX_CHANGESETS - newChangesets.length);

                changesetsFifo = newChangesets.concat(changesetsFifo);
            }

            async function displayNextMessage() {
                if (changesetsFifo.length === 0) {
                    console.log('No changesets');
                    return; 
                }

                const changeset = changesetsFifo[changesetIndex];

                const messageHtml = await formatChangeset(changeset);

                const chatUl = document.getElementById('changesetRows');
                chatUl.insertAdjacentHTML('afterbegin', messageHtml);
                setAnimation();

                // Increment the index for the next message:
                changesetIndex++;
                
                if(changesetIndex > changesetsFifo.length - 1)
                    changesetIndex = 0;
            }

            function setAnimation() {
                let els = document.querySelectorAll(".chat-ul li.up");
                let timer = 200;
                for(const el of els) {
                    setTimeout(()=>{
                        el.classList.remove('up');
                        el.classList.add('down');                        
                    }, timer);
                    timer += 100;
                }
            }

            async function latLong2LocationName(lat, lon, useIntersectionName) {
                // we don't want to error on an issue, just don't show the street
                if (!apikey || apikey.length === 0) {
                    console.log('no API key provided for reverse geocoding.');
                    return '';
                }

                if (!lat || lat.length === 0 || !lon || lon.length === 0) {
                    console.log('invalid latitude or longitude provided for reverse geocoding.');
                    return '';
                }

                try {
                    const response = await fetch(`https://api.tomtom.com/search/2/reverseGeocode/crossStreet/${lat},${lon}.json?key=${apikey}`);
                    if (!response.ok) {
                        throw new Error('failed to fetch address');
                    }

                    const data = await response.json();
                    if (!data || !data.addresses || data.addresses.length === 0 || !data.addresses[0].address || data.addresses[0].address.length === 0) {
                        console.log('unable to parse data from' + JSON.stringify(data));
                        return '';
                    }

                    const locationName = useIntersectionName ? data.addresses[0].address.streetName : data.addresses[0].address.street;
                    return 'at ' + locationName || '';
                }
                catch (error) {
                    console.log('unable to reverse geocode.');
                    return '';
                }
            }

            async function fetchChangesetXml(changesetId) {
                if (TEST_MODE.length > 0) {
                    // If we're in test mode, return a random test XML
                    console.log('in test mode, returning random test XML');
                    return TEST_XML[Math.floor(Math.random() * TEST_XML.length)];
                }

                try {
                    const response = await fetch(POSM_API_URL + 'changeset/' + changesetId + '/download', {
                        headers: {
                            'Authorization': 'Bearer ' + accessToken,
                            'X-Workspace': WORKSPACE_ID
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`failed to fetch changeset ${changesetId}: ${response.statusText}`);
                    }
                    
                    return await response.text();
                } catch (error) {
                    console.log("Error fetching changeset: " + error);
                    return null;
                }
            }

            async function fetchWaysLatLong(waysId) {
                try {
                    const waysResponse = await fetch(POSM_API_URL + 'ways.json?ways=' + waysId, {
                        headers: {
                            'Authorization': 'Bearer ' + accessToken,
                            'X-Workspace': WORKSPACE_ID
                        }
                    });

                    if (!waysResponse.ok) {
                        throw new Error(`failed to fetch ways ${waysId}: ${waysResponse.statusText}`);
                    }
                    
                    const waysJson = await waysResponse.json();
                    const nodes = waysJson.elements[0].nodes;
                    const nodesResponse = await fetch(POSM_API_URL + 'nodes.json?nodes=' + nodes[0], {
                        headers: {
                            'Authorization': 'Bearer ' + accessToken,
                            'X-Workspace': WORKSPACE_ID
                        }
                    });

                    if (!nodesResponse.ok) {
                        throw new Error(`failed to fetch node: ${nodesResponse.statusText}`);
                    }

                    const nodesJson = await nodesResponse.json();
                    return {
                        lat: nodesJson.elements[0].lat,
                        lon: nodesJson.elements[0].lon
                    };
                } catch (error) {
                    console.log("Error fetching ways details: " + error);
                    return null;
                }
            }

            function randomVerb() {
                const verbs = [
                    "identified", "found", "distinguished", "pinpointed", "determined", "recognized", "observed", "noted", "discovered", "detected", "marked", "tagged", "labeled", "classified", "categorized", "specified", "designated", "indicated", "signaled", "reported", "documented", "recorded", "logged", "registered"
                ];
                return verbs[Math.floor(Math.random() * verbs.length)];
            }
    
            function bool2text(value) {
                if (value === 'N' || value === 'no' || value === 'false' || value === 'n') {
                    return '<strong>' + 'not' + '</strong>';
                } else {
                    return "";
                }
            }

            function dynabool2text(word, value) {
                if (value === 'N' || value === 'no' || value === 'false' || value === 'n') {
                    return word + ' <strong>' + 'not' + '</strong>';
                } else {
                    return '<strong>' + word + '</strong>';
                }
            }

            function enum2text(value) {
                const enumDict = {
                    "1": "very poor",
                    "2": "poor",
                    "3": "fair",
                    "4": "good",
                    "5": "excellent"
                };

                return '<strong>' + enumDict[value] + '</strong>';
            }

            function photo2text(value) {
                let result = '';
                if (value && value.length > 0) {
                    value = value.split(',');
                    result = value.map(image => {
                        return `<img src="${image}" class="rounded mx-auto d-block img-thumbnail" alt="AVIV ScoutRoute Image" />`;
                    }).join('');
                    result = '<div>' + result + '</div>';
                }

                return result;
            }

            async function translateTag2Html(changeset, k, v, lat, lon, useIntersectionName) {
                const verb = randomVerb();
                let result = TAG_DICT[k];
                
                if (!result) {
                    throw new Error('unsupported tag ' + k + ' in changeset ' + changeset.id);
                }

                // replace placeholders with actual values
                result = result.replace('[location]', await latLong2LocationName(lat, lon, useIntersectionName));
                result = result.replace('[value]', '<strong>' + v + '</strong>');
                result = result.replace('[enum]', enum2text(v));
                result = result.replace('[not]', bool2text(v));
                result = result.replace('[does not]', dynabool2text('does', v));
                result = result.replace('[is not]', dynabool2text('is', v));
                result = result.replace('[photo]', photo2text(v));

                return randomVerb() + ' ' + result;
            }

            async function xml2text(changeset, xml) {
                let result = '';

                const parser = new DOMParser();
                const doc = parser.parseFromString(xml, "text/xml");
                const modify_tags = Array.from(doc.getElementsByTagName("modify"));

                // create a map of unique tags and the values we need to make text for each
                var uniqueKV = {};
                for (const modify_tag of modify_tags) {
                    const nodes = Array.from(modify_tag.getElementsByTagName("node"));
                    for (const node of nodes) {
                        const id = node.getAttribute("id");
                        const lat = node.getAttribute("lat");
                        const lon = node.getAttribute("lon");
                        const useIntersectionName = true;

                        const tags = Array.from(node.getElementsByTagName("tag"));
                        for (const tag of tags) {
                            const k = tag.getAttribute("k");
                            const v = tag.getAttribute("v");

                            if (k in TAG_DICT) {
                                uniqueKV[k] = { k, v, lat, lon, useIntersectionName };
                            }
                        }
                    }

                    const ways = Array.from(modify_tag.getElementsByTagName("way"));
                    for (const way of ways) {
                        const id = way.getAttribute("id");
                        const latlong = await fetchWaysLatLong(id);

                        let lat = null;
                        let lon = null;
                        const useIntersectionName = false;
                        if (latlong) {
                            lat = latlong["lat"];
                            lon = latlong["lon"];
                        }

                        const tags = Array.from(way.getElementsByTagName("tag"));
                        for (const tag of tags) {
                            const k = tag.getAttribute("k");
                            const v = tag.getAttribute("v");

                            if (k in TAG_DICT) {
                                uniqueKV[k] = { k, v, lat, lon, useIntersectionName };
                            }
                        }
                    }          
                }

                // now turn that map of unique tags into text snippets:
                for(const change of Object.values(uniqueKV)) {
                    const color = ( changeset.id % 2 == 0 ) ? ' alt' : '';
                    const snippet = await translateTag2Html(changeset, change.k, change.v, change.lat, change.lon, change.useIntersectionName);

                    result += `<li class="up">
                        <div class="message-data">
                        <span class="message-data-name">${changeset.user}</span></div>
                    
                        <div class="message${color}">
                            <div class="comment">
                                ${snippet}
                            </div>
                        </div>
                    </li>`;
                }

                return result;
            }

            // get rid of this
            async function formatChangeset(changeset) {
                const xml = await fetchChangesetXml(changeset.id);
                return await xml2text(changeset, xml);
            }

            document.addEventListener('DOMContentLoaded', function() {
                login();
            });
        </script>
    </body>
</html>