<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="TASKAR Center for Accessible Technology - Aviv ScoutRoute Feedback">
        <title>Aviv ScoutRoute Feedback</title>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css" rel="stylesheet">
        <link href='https://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
        <style>
            *, *:before, *:after {
                box-sizing: border-box;
            }
            body,
            .container {
                font-family: 'Open Sans', sans-serif;
                font-size: 24px;
                background-color: #330872;
                overflow-y: hidden;
            }
            .chat .chat-history {
                padding: 30px 30px 20px;
            }
            .chat .chat-history .message-data {
                margin-bottom: 22px;
                color: white;
            }
            .chat .chat-history .message-data-time {
                padding-left: 6px;
            }
            .chat .chat-history .message-data-name {
                font-weight: bold;
            }
            .chat .chat-history .message {
                padding: 18px 20px;
                line-height: 26px;
                border-radius: 5px;
                margin-bottom: 30px;
                width: 90%;
                position: relative;
                background-color: #e2f2f2;
            }

            .chat .chat-history .message:after {
                content: "";
                position: absolute;
                top: -15px;
                left: 20px;
                border-width: 0 15px 15px;
                border-style: solid;
                border-color: #e2f2f2 transparent;
                display: block;
                width: 0;
            }

            .chat .chat-history .message.alt {
                background-color: #f8f8ea;
            }
            .chat .chat-history .message.alt:after {
                border-color: #f8f8ea transparent;
            }

            .chat .chat-message {
                padding: 30px;
            }

            .chat .comment {
                padding-top: 20px;
                padding-bottom: 20px;
                color: black;
            }
            file-o, .chat .chat-message .fa-file-image-o {
                color: white;
                cursor: pointer;
            }

            .chat-ul li{
                list-style-type: none;
                padding-top: 20px;
                padding-bottom: 20px;
            }

            .align-left {
                text-align: left;
            }

            .align-right {
                text-align: right;
            }

            .float-right {
                float: right;
            }

            .clearfix:after {
                visibility: hidden;
                display: block;
                font-size: 0;
                content: " ";
                clear: both;
                height: 0;
            }

            .up {
                transform: translateY(-100vw);
            }

            .down {
                transform: translateY(0);
                transition: 
                    transform .8s cubic-bezier(0.175, 0.885, 0.32, 1.1);
            }

            strong {
                font-weight: 900;
            }
        </style>
    </head>
    <body>
        <div id=“feed” class="container clearfix">
            <div class="chat">   
                <div class="chat-history">
                    <ul class="chat-ul" id="changesetRows">
                        <li>
                            <div class="message-data">
                                <span class="message-data-name">William Langland</span>
                            </div>
                            <div class="message">
                                <div class="comment">Patience is a virtue...</div>
                            </div>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/js/bootstrap.bundle.min.js"></script>
        <script>
            const URL_PARAMS = new URLSearchParams(window.location.search);
            const ENV = URL_PARAMS.get('e') || ''; // default to prod if not passed
            const WORKSPACE_ID = URL_PARAMS.get('w') || 125; // default to SDF if not passed

            const ENV_URL = (ENV.length > 0) ? '-' + ENV : '';
            const TDEI_API_URL = `https://api${ENV_URL}.tdei.us/api/v1/`;
            const POSM_API_URL = `https://osm.workspaces${ENV_URL}.sidewalks.washington.edu/api/0.6/`;
            const MAX_CHANGESETS = 10;
            const POLL_CHANGESET_SECONDS = 120;
            const POLL_DISPLAY_MESSAGE_SECONDS = 30;
            
            let accessToken = undefined;
            let minCreationTime = '2025-01-01';
            let changesetsFifo = [];
            let changesetIndex = 0;

            async function login() {
                const username = prompt('TDEI Username');
                const password = prompt('TDEI Password');

                const response = await fetch(TDEI_API_URL + 'authenticate', {
                    method: 'POST',
                    body: JSON.stringify({ username, password }),
                    headers: { 'Content-Type': 'application/json' }
                });

                if (!response.ok) {
                    alert('Login failed: ' + response.statusText);
                    return;
                }

                const body = await response.json();
                accessToken = body.access_token; // Currently expires in 24 hours

                start();
            }

            async function start() {
                if (!accessToken) { alert('Please log in first.'); }
                await refreshChangesets();
                setInterval(refreshChangesets, POLL_CHANGESET_SECONDS * 1000);
                setInterval(displayNextMessage, POLL_DISPLAY_MESSAGE_SECONDS * 1000);
            }

            async function refreshChangesets() {
                // Fetch the newest changesets from the POSM. This API returns changesets 
                // ordered from newest to oldest by default:
                //
                const params = `?from=${minCreationTime}&limit=${MAX_CHANGESETS}`;
                let response = null;

                try
                {
                    response = await fetch(POSM_API_URL + 'changesets.json' + params, {
                        headers: {
                        'Authorization': 'Bearer ' + accessToken,
                        'X-Workspace': WORKSPACE_ID
                        }
                    });
                }
                catch (error) {
                    return;
                }

                // if we aren’t able to fetch, start over with the data we do have
                // how do we deal with auth token expiring?  different response value?
                if (!response.ok) {
                    return;
                }

                const newChangesets = (await response.json()).changesets;
                if (!newChangesets.length) { return; }

                // We'll remember the creation time of the newest changeset so that we can 
                // constrain our next cycle to include only changesets newer than this:
                const newMinCreationTime = new Date(newChangesets[0].created_at);
                newMinCreationTime.setSeconds(newMinCreationTime.getSeconds() + 1);
                minCreationTime = newMinCreationTime.toISOString();

                // Next, we'll remove any older changesets that exceed the maximum number 
                // of changesets that we want to display at one time:
                //
                const oldChangesets = changesetsFifo.splice(MAX_CHANGESETS - newChangesets.length);
                // (We don't do anything with these in this example, but a full implementation
                // would remove these from the map.)

                // Display any new changesets on the screen...
                //
                changesetsFifo = newChangesets.concat(changesetsFifo);
                //window.changesetRows.innerHTML = changesetsFifo.map(formatChangeset).join('');
            }

            async function displayNextMessage() {
                if (changesetsFifo.length === 0) {
                    return; // No changesets to display
                }

                // Get the next changeset to display:
                const changeset = changesetsFifo[changesetIndex];
                if (!changeset) {
                    return; // No more changesets to display
                }

                let messageHtml = '';
                // Display the changeset in the chat history:
                try {
                    messageHtml = await formatChangeset(changeset, changesetIndex);
                } catch (error) {
                    // Skip this changeset and move to the next one
                    changesetIndex = (changesetIndex + 1) % changesetsFifo.length;
                    return;
                }

                const chatUl = document.getElementById('changesetRows');
                chatUl.insertAdjacentHTML('afterbegin', messageHtml);

                let el = document.querySelector("li");
                if (el) {
                    setAnimation(el);
                }

                // Increment the index for the next message:
                changesetIndex = (changesetIndex + 1) % changesetsFifo.length;
            }

            function setAnimation(el) {
                setTimeout(()=>{
                    el.classList.remove('up');
                    el.classList.add('down');
                }, 200);
            }

            function generateImageHtmlFromChangeset(changeset) {
                let result = '';

                let images = changeset.tags["ext:kartaview_url"];
                if (images && images.length > 0) {
                    images = images.split(',');
                    result = images.map(image => {
                        return `<img src="${image}" class="img-fluid" alt="Comment Image" />`;
                    }).join('');
                    result = '<div>' + result + '</div>';
                }

                return result;
            }

            async function fetchChangesetXml(changesetId) {
                try {
                    const response = await fetch(POSM_API_URL + 'changeset/' + changesetId + '/download', {
                        headers: {
                            'Authorization': 'Bearer ' + accessToken,
                            'X-Workspace': WORKSPACE_ID
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`Failed to fetch changeset ${changesetId}: ${response.statusText}`);
                    }

                    return await response.text();
                } catch (error) {
                    console.error(error);
                    return null;
                }
            }

            function randomVerb()
            {
                const verbs = [
                    "identified", "found", "distinguished", "pinpointed", "determined", "recognized", "observed", "noted", "discovered", "detected", "marked", "tagged", "labeled", "classified", "categorized", "specified", "defined", "designated", "indicated", "signaled", "reported", "documented", "recorded", "logged", "registered"
                ];
                return verbs[Math.floor(Math.random() * verbs.length)];
            }
    
            function xml2text(xml) {
                let result = '';
                const parser = new DOMParser();
                const doc = parser.parseFromString(xml, "text/xml");
                const modify_tags = Array.from(doc.getElementsByTagName("modify"));
                let nodes = [];
                let ways = [];

                for (var i = 0; i < modify_tags.length; i++) {
                    nodes = Array.from(modify_tags[i].getElementsByTagName("node"));

                    if (nodes.length > 0) {
                        result += nodes.map(el => {
                            const tags = Array.from(el.getElementsByTagName("tag"));
                            const tagText = tags.map(tag => randomVerb() + ` <strong>${tag.getAttribute("k")}</strong> as <strong>${tag.getAttribute("v")}</strong>`).join('<br /><br />');
                            return tagText;
                        }).join('') + '<br /><br />';
                    }

                    //ways = modify_tags[i].getElementsByTagName("way");
                }

                // snip the trailing <br /><br /> at the end
                if (result.length > 0) {
                    result = result.substring(0, result.length - 12);
                }

                return result;
            }

            async function generateTextFromChangeset(changeset) {
                const xml = await fetchChangesetXml(changeset.id);
                let result = xml2text(xml);

                if (result.length === 0) {
                    throw new Exception('empty changeset!');
                }

                return '<div class="comment">' + result + '</div>';
            }

            /**
            function computeChangesetDifference(xml1, xml2) {
                const parser = new DOMParser();
                const doc1 = parser.parseFromString(xml1, "text/xml");
                const doc2 = parser.parseFromString(xml2, "text/xml");

                const diff = {
                    added: [],
                    modified: [],
                    deleted: []
                };

                const elements1 = Array.from(doc1.getElementsByTagName("node"));
                const elements2 = Array.from(doc2.getElementsByTagName("node"));

                const map1 = new Map(elements1.map(el => [el.getAttribute("id"), el]));
                const map2 = new Map(elements2.map(el => [el.getAttribute("id"), el]));

                // Detect added and modified elements
                for (const [id, el2] of map2.entries()) {
                    if (!map1.has(id)) {
                        diff.added.push(el2);
                    } else if (el2.getAttribute("version") !== map1.get(id).getAttribute("version")) {
                        diff.modified.push(el2);
                    }
                }

                // Detect deleted elements
                for (const id of map1.keys()) {
                    if (!map2.has(id)) {
                        diff.deleted.push(map1.get(id));
                    }
                }

                return diff;
            }

            async function compareChangesets(changesetId1, changesetId2) {
                const xml1 = await fetchChangesetXml(changesetId1);
                const xml2 = await fetchChangesetXml(changesetId2);

                if (!xml1 || !xml2) {
                    alert("Failed to fetch one or both changesets.");
                    return;
                }

                const diff = computeChangesetDifference(xml1, xml2);

                console.log("Added nodes:", diff.added);
                console.log("Modified nodes:", diff.modified);
                console.log("Deleted nodes:", diff.deleted);

                alert(`Comparison complete:
                - Added: ${diff.added.length}
                - Modified: ${diff.modified.length}
                - Deleted: ${diff.deleted.length}`);
            }

            **/

            async function formatChangeset(changeset, changesetIndex) {
                const color = ( changesetIndex % 2 === 0 ) ? ' alt' : '';
                const imageHtml = generateImageHtmlFromChangeset(changeset);
                const textHtml = await generateTextFromChangeset(changeset);

                return `<li class="up"><div class="message-data">
                <span class="message-data-name">${changeset.user}</span></div>
                <div class="message${color}">
                ${textHtml}
                ${imageHtml}
                </div>
                </li>`;
            }

            document.addEventListener('DOMContentLoaded', function() {
                login();
            });
        </script>
    </body>
</html>