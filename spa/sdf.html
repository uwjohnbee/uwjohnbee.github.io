<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="TASKAR Center for Accessible Technology - AVIV ScoutRoute Feedback">
        <title>AVIV ScoutRoute Feedback</title>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/css/bootstrap.min.css" rel="stylesheet">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" rel="stylesheet">
        <style>
            *, *:before, *:after {
                box-sizing: border-box;
            }
            body,
            .container {
                font-family: 'Open Sans', sans-serif;
                font-size: 24px;
                background-color: #330872;
                overflow-y: hidden;
            }
            .chat .chat-history {
                padding: 30px 30px 20px;
            }
            .chat .chat-history .message-data {
                margin-bottom: 22px;
                color: white;
            }
            .chat .chat-history .message-data-time {
                padding-left: 6px;
            }
            .chat .chat-history .message-data-name {
                font-weight: bold;
            }
            .chat .chat-history .message {
                padding: 18px 20px;
                line-height: 26px;
                border-radius: 5px;
                margin-bottom: 30px;
                width: 90%;
                position: relative;
                background-color: #e2f2f2;
            }

            .chat .chat-history .message:after {
                content: "";
                position: absolute;
                top: -15px;
                left: 20px;
                border-width: 0 15px 15px;
                border-style: solid;
                border-color: #e2f2f2 transparent;
                display: block;
                width: 0;
            }

            .chat .chat-history .message.alt {
                background-color: #f8f8ea;
            }
            .chat .chat-history .message.alt:after {
                border-color: #f8f8ea transparent;
            }

            .chat .chat-message {
                padding: 30px;
            }

            .chat .comment {
                padding-top: 20px;
                padding-bottom: 20px;
                color: black;
            }
            file-o, .chat .chat-message .fa-file-image-o {
                color: white;
                cursor: pointer;
            }

            .chat-ul li{
                list-style-type: none;
                padding-top: 20px;
                padding-bottom: 20px;
            }

            .align-left {
                text-align: left;
            }

            .align-right {
                text-align: right;
            }

            .float-right {
                float: right;
            }

            .clearfix:after {
                visibility: hidden;
                display: block;
                font-size: 0;
                content: " ";
                clear: both;
                height: 0;
            }

            .up {
                transform: translateY(-100vw);
            }

            .down {
                transform: translateY(0);
                transition: 
                    transform .8s cubic-bezier(0.175, 0.885, 0.32, 1.1);
            }

            strong {
                font-weight: 600;
            }
        </style>
    </head>
    <body>
        <div id=“feed” class="container clearfix">
            <div class="chat">   
                <div class="chat-history">
                    <ul class="chat-ul" id="changesetRows">
                        <li>
                            <div class="message-data">
                                <span class="message-data-name">William Langland</span>
                            </div>
                            <div class="message">
                                <div class="comment">Patience is a virtue...</div>
                            </div>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.7/dist/js/bootstrap.bundle.min.js"></script>
        <script>
            const URL_PARAMS = new URLSearchParams(window.location.search);
            const ENV = URL_PARAMS.get('e') || ''; // default to prod if not passed
            const WORKSPACE_ID = URL_PARAMS.get('w') || 125; // default to SDF if not passed
            const TEST_MODE = URL_PARAMS.get('t') || ''; // default to live mode

            const ENV_URL = (ENV.length > 0) ? '-' + ENV : '';
            const TDEI_API_URL = `https://api${ENV_URL}.tdei.us/api/v1/`;
            const POSM_API_URL = `https://osm.workspaces${ENV_URL}.sidewalks.washington.edu/api/0.6/`;
            const MAX_CHANGESETS = 30;
            const POLL_CHANGESET_SECONDS = 120;
            const POLL_DISPLAY_MESSAGE_SECONDS = 30;

            const TAG_DICT = {
                // 1. Nodes
                //      A. Intersections
                "ext:intersection:well_maintained": "the intersection [location] [is not] well-maintained.",
                //          No | Yes
                "ext:intersection:visibility_rating": "the intersection's visibility of pedestrians to drivers [location] is [enum].",
                //          1 = Very Poor | 2 = Poor | 3 = Fair | 4 = Good | 5 = Excellent
                "ext:intersection:safe_and_accessible": "the intersection [location] [is not] safe and accessible for people with disabilities or mobility aids.",
                //          No | Yes
                "ext:intersection:picture": "an intersection [location] looks like: [photo]", 
                //          No | Yes, ties to ext:kartaview_url
                //      B. Curbs
                "kerb": "a curb's type [location] is [value].",
                //          Raised | Ramp | Flush
                "tactile_paving": "a curb [location] [does not] have tactile paving.",
                //          No | Yes
                "ext:ramp:alignment_with_crossing": "a ramp [location] is [value] with the direction of the crossing.",
                //          Misaligned | Aligned
                // 2. Ways
                //      A. Footways
                "surface": "a footway's surface material [location] is [value].",
                //          Concrete | Asphalt | Brick
                "ext:footway:surface:condition": "a footway's surface condition [location] is [enum].",
                //          1 = Very Poor | 2 = Poor | 3 = Fair | 4 = Good | 5 = Excellent
                "ext:footway:disruptions:count": "the number of disruptions over 2 inches on a footway [location] is [value].",
                //          0 - 50
                //      B. Sidewalks
                "ext:sidewalk:obstruction": "a sidewalk [location] [does not] have temporary obstructions.", 
                //          No | Yes
                "surface": "a sidewalk's surface material [location] is [value].",
                //          Concrete | Asphalt | Brick
                "ext:sidewalk:surface:condition": "a sidewalk's surface condition [location] is [enum].",
                //          1 = Very Poor | 2 = Poor | 3 = Fair | 4 = Good | 5 = Excellent
                "ext:sidewalk:disruptions:count": "the number of disruptions over 2 inches on a sidewalk [location] is [value].",
                //          0 - 50
                //      C. Crossings
                "surface": "a crossing's surface material [location] is [value].",
                //          Concrete | Asphalt | Brick
                "ext:crossing:surface:condition": "a crossing's surface condition [location] is [enum].",
                //          1 = Very Poor | 2 = Poor | 3 = Fair | 4 = Good | 5 = Excellent
                "ext:crossing:disruptions:count": "the number of disruptions over 2 inches at a crosswalk [location] is [value].",
                //          0 - 50
                "crossing:markings": "a crosswalk [location] [does not] have markings on the roadway.",
                //          No | Yes
                "ext:crossing:markings:condition": "the condition of the markings [location] is [enum].",
                //          1 = Very Poor | 2 = Poor | 3 = Fair | 4 = Good | 5 = Excellent
                "ext:crossing:signals": "a crosswalk [location] [does not] have signals for pedestrians.",
                //          No | Yes
                "ext:crossing:signals:button": "a crossing [location] [does not] have a push button for pedestrians.",
                //          No | Yes
                "ext:crossing:signals:sound": "a crossing [location] [does not] have an audible indication for when it is safe to cross.",
                //          No | Yes
                "ext:crossing:signals:vibration": "a crossing [location] [does not] have a vibrating tactile indication for when it is safe to cross.",
                //          No | Yes
                "ext:crossing:signals:arrow": "a crossing [location] [does not] have a tactile arrow for pedestrians.",
                //          No | Yes
                "ext:crossing:signals:arrow:alignment": "a crossing [location] is [value] with the direction of travel.",
                //          Misaligned | Aligned
                "ext:crossing:signals:button:reachable": "a crossing [location] [is not] reachable by people with mobility aids."
                //          No | Yes
            };

            const TEST_XML = [
            `<?xml version="1.0" encoding="UTF-8"?>
            <osmChange version="0.6" generator="CGImap 0.10.0.2507212011 (22 788a64db3727)" copyright="OpenStreetMap and contributors" attribution="http://www.openstreetmap.org/copyright" license="http://opendatacommons.org/licenses/odbl/1-0/">
                <modify>
                    <node id="1883150" visible="true" version="2" changeset="1" timestamp="2025-08-06T00:45:14Z" user="Node of Your Business" uid="8" lat="47.6259971" lon="-122.3384143">
                        <nd ref="6768521"/>
                        <nd ref="6768520"/>
                        <tag k="ext:intersection:visibility" v="2"/>
                    </way>
                </modify>
            </osmChange>`,
            `<?xml version="1.0" encoding="UTF-8"?>
            <osmChange version="0.6" generator="CGImap 0.10.0.2507212011 (22 788a64db3727)" copyright="OpenStreetMap and contributors" attribution="http://www.openstreetmap.org/copyright" license="http://opendatacommons.org/licenses/odbl/1-0/">
                <modify>
                    <way id="1841820" visible="true" version="2" changeset="2" timestamp="2025-08-06T00:45:14Z" user="Ways and Means" uid="8">
                        <nd ref="6605122"/>
                        <nd ref="6605121"/>
                        <tag k="surface" v="brick"/>
                    </way>
                </modify>
            </osmChange>`,
            `<?xml version="1.0" encoding="UTF-8"?>
            <osmChange version="0.6" generator="CGImap 0.10.0.2507212011 (22 788a64db3727)" copyright="OpenStreetMap and contributors" attribution="http://www.openstreetmap.org/copyright" license="http://opendatacommons.org/licenses/odbl/1-0/">
                <modify>
                    <node id="1883150" visible="true" version="2" changeset="3" timestamp="2025-08-06T00:45:14Z" user="Node of Your Business" uid="8" lat="47.6259971" lon="-122.3384143">
                        <nd ref="6768521"/>
                        <nd ref="6768520"/>
                        <tag k="ext:intersection:maintained" v="n"/>
                    </way>
                </modify>
            </osmChange>`,
            `<?xml version="1.0" encoding="UTF-8"?>
            <osmChange version="0.6" generator="CGImap 0.10.0.2507212011 (22 788a64db3727)" copyright="OpenStreetMap and contributors" attribution="http://www.openstreetmap.org/copyright" license="http://opendatacommons.org/licenses/odbl/1-0/">
                <modify>
                    <way id="1841820" visible="true" version="2" changeset="4" timestamp="2025-08-06T00:45:14Z" user="Ways and Means" uid="8">
                        <nd ref="6605122"/>
                        <nd ref="6605121"/>
                        <tag k="ext:crossing:signals:vibration" v="y"/>
                    </way>
                </modify>
            </osmChange>`,
            `<?xml version="1.0" encoding="UTF-8"?>
            <osmChange version="0.6" generator="CGImap 0.10.0.2507212011 (22 788a64db3727)" copyright="OpenStreetMap and contributors" attribution="http://www.openstreetmap.org/copyright" license="http://opendatacommons.org/licenses/odbl/1-0/">
                <modify>
                    <node id="1883150" visible="true" version="2" changeset="3" timestamp="2025-08-06T00:45:14Z" user="Node of Your Business" uid="8" lat="47.6259971" lon="-122.3384143">
                        <nd ref="6768521"/>
                        <nd ref="6768520"/>
                        <tag k=""ext:ramp:alignment_with_crossing" v="misaligned"/>
                    </way>
                </modify>
            </osmChange>`
            ];

            let accessToken = undefined;
            let apikey = undefined;
            let minCreationTime = '2025-08-12';
            let changesetsFifo = [];
            let changesetIndex = 0;

            async function login() {
                const username = prompt('TDEI Username');
                const password = prompt('TDEI Password');
                apikey = prompt('TomTom API Key (optional)');

                const response = await fetch(TDEI_API_URL + 'authenticate', {
                    method: 'POST',
                    body: JSON.stringify({ username, password }),
                    headers: { 'Content-Type': 'application/json' }
                });

                if (!response.ok) {
                    alert('Login failed: ' + response.statusText);
                    return;
                }

                const body = await response.json();
                accessToken = body.access_token; // Currently expires in 24 hours

                start();
            }

            async function start() {
                if (!accessToken) { alert('Please log in first.'); }
                await refreshChangesets();
                setInterval(refreshChangesets, POLL_CHANGESET_SECONDS * 1000);
                setInterval(displayNextMessage, POLL_DISPLAY_MESSAGE_SECONDS * 1000);
            }

            async function refreshChangesets() {
                // Fetch the newest changesets from the POSM. This API returns changesets 
                // ordered from newest to oldest by default:
                const params = `?from=${minCreationTime}&limit=${MAX_CHANGESETS}`;
                let response = null;

                try
                {
                    response = await fetch(POSM_API_URL + 'changesets.json' + params, {
                        headers: {
                        'Authorization': 'Bearer ' + accessToken,
                        'X-Workspace': WORKSPACE_ID
                        }
                    });
                }
                catch (error) {
                    return;
                }

                // if we aren’t able to fetch, start over with the data we do have
                // how do we deal with auth token expiring?  different response value?
                if (!response.ok) {
                    return;
                }

                const newChangesets = (await response.json()).changesets;
                if (!newChangesets.length) { return; }

                // We'll remember the creation time of the newest changeset so that we can 
                // constrain our next cycle to include only changesets newer than this:
                const newMinCreationTime = new Date(newChangesets[0].created_at);
                newMinCreationTime.setSeconds(newMinCreationTime.getSeconds() + 1);
                minCreationTime = newMinCreationTime.toISOString();

                // Next, we'll remove any older changesets that exceed the maximum number 
                // of changesets that we want to display at one time:
                //
                const oldChangesets = changesetsFifo.splice(MAX_CHANGESETS - newChangesets.length);
                // (We don't do anything with these in this example, but a full implementation
                // would remove these from the map.)

                // Display any new changesets on the screen...
                //
                changesetsFifo = newChangesets.concat(changesetsFifo);
            }

            async function displayNextMessage() {
                if (changesetsFifo.length === 0) {
                    console.log('no changesets to display');
                    return; // No changesets to display
                }

                // Get the next changeset to display:
                const changeset = changesetsFifo[changesetIndex];
                if (!changeset) {
                    console.log('index out of bounds for changesets, starting over');
                    changesetIndex = 0;
                    await displayNextMessage();
                }

                let messageHtml = '';
                // Display the changeset in the chat history:
                try {
                    messageHtml = await formatChangeset(changeset, changesetIndex);
                } catch (error) {
                    // Skip this changeset and move to the next one
                    console.log(error.message);
                    if (changesetIndex >= changesetsFifo.length - 1) {
                        console.log('reached end of changesets, waiting for refresh');
                        changesetIndex = 0;
                        return;
                    }
                    else {
                        changesetIndex++;
                        await displayNextMessage();
                    }
                }

                const chatUl = document.getElementById('changesetRows');
                chatUl.insertAdjacentHTML('afterbegin', messageHtml);

                let el = document.querySelector("li");
                if (el) {
                    setAnimation(el);
                }

                // Increment the index for the next message:
                changesetIndex = (changesetIndex + 1) % changesetsFifo.length;
            }

            function setAnimation(el) {
                setTimeout(()=>{
                    el.classList.remove('up');
                    el.classList.add('down');
                }, 200);
            }

            async function latLong2LocationName(lat, lon) {
                // we don't want to error on an issue, just don't show the street
                if (!apikey || apikey.length === 0) {
                    console.log('no API key provided for reverse geocoding.');
                    return '';
                }

                if (!lat || lat.length === 0 || !lon || lon.length === 0) {
                    console.log('invalid latitude or longitude provided for reverse geocoding.');
                    return '';
                }

                try {
                    const response = await fetch(`https://api.tomtom.com/search/2/reverseGeocode/crossStreet/${lat},${lon}.json?key=${apikey}`);
                    if (!response.ok) {
                        throw new Error('failed to fetch address');
                    }

                    const data = await response.json();
                    if (!data || !data.addresses || data.addresses.length === 0 || !data.addresses[0].address || data.addresses[0].address.length === 0) {
                        console.log('unable to parse data from' + JSON.stringify(data));
                        return '';
                    }

                    return 'at ' + data.addresses[0].address.streetName || '';
                }
                catch (error) {
                    console.log('unable to reverse geocode.');
                    return '';
                }
            }

            async function fetchChangesetXml(changesetId) {
                try {
                    const response = await fetch(POSM_API_URL + 'changeset/' + changesetId + '/download', {
                        headers: {
                            'Authorization': 'Bearer ' + accessToken,
                            'X-Workspace': WORKSPACE_ID
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`failed to fetch changeset ${changesetId}: ${response.statusText}`);
                    }

                    if (TEST_MODE.length > 0) {
                        // If we're in test mode, return a random test XML
                        console.log('in test mode, returning random test XML');
                        return TEST_XML[Math.floor(Math.random() * TEST_XML.length)];
                    }

                    return await response.text();
                } catch (error) {
                    console.log(error);
                    return null;
                }
            }

            function randomVerb()
            {
                const verbs = [
                    "identified", "found", "distinguished", "pinpointed", "determined", "recognized", "observed", "noted", "discovered", "detected", "marked", "tagged", "labeled", "classified", "categorized", "specified", "defined", "designated", "indicated", "signaled", "reported", "documented", "recorded", "logged", "registered"
                ];
                return verbs[Math.floor(Math.random() * verbs.length)];
            }
    
            function bool2text(value) {
                if (value === 'N' || value === 'no' || value === 'false' || value === 'n') {
                    return '<strong>' + 'not' + '</strong>';
                } else {
                    return "";
                }
            }

            function dynabool2text(word, value) {
                if (value === 'N' || value === 'no' || value === 'false' || value === 'n') {
                    return word + ' <strong>' + 'not' + '</strong>';
                } else {
                    return '<strong>' + word + '</strong>';
                }
            }

            function enum2text(value) {
                const enumDict = {
                    "1": "very poor",
                    "2": "poor",
                    "3": "fair",
                    "4": "good",
                    "5": "excellent"
                };

                return '<strong>' + enumDict[value] + '</strong>';
            }

            function photo2text(changeset) {
                let result = '';
                let images = changeset.tags["ext:kartaview_url"];
                if (images && images.length > 0) {
                    images = images.split(',');
                    result = images.map(image => {
                        return `<img src="${image}" class="img-fluid" alt="Changeset Image" />`;
                    }).join('');
                    result = '<div>' + result + '</div>';
                }

                return result;
            }

            async function translateTag2Html(changeset, k, v, lat, lon) {
                const verb = randomVerb();
                let result = TAG_DICT[k];
                
                if (!result) {
                    throw new Error('unsupported tag ' + k + ' in changeset ' + changeset.id);
                }

                // replace placeholders with actual values
                result = result.replace('[location]', await latLong2LocationName(lat, lon));
                result = result.replace('[value]', '<strong>' + v + '</strong>');
                result = result.replace('[enum]', enum2text(v));
                result = result.replace('[not]', bool2text(v));
                result = result.replace('[does not]', dynabool2text('does', v));
                result = result.replace('[is not]', dynabool2text('is', v));
                result = result.replace('[photo]', photo2text(changeset));

                return randomVerb() + ' ' + result + '<br /><br />';
            }

            async function xml2text(changeset, xml) {
                let result = '';
                const parser = new DOMParser();
                const doc = parser.parseFromString(xml, "text/xml");
                const modify_tags = Array.from(doc.getElementsByTagName("modify"));
                let nodes = [];
                let ways = [];
                let nodesways = [];
                let isQuestXML = false;

                for (const modify_tag of modify_tags) {
                    nodes = Array.from(modify_tag.getElementsByTagName("node"));
                    // do we need to read ways differently than nodes?
                    ways = Array.from(modify_tag.getElementsByTagName("way"));
                    nodesways = nodes.concat(ways);

                    for (const item of nodesways) {
                        //alert(new XMLSerializer().serializeToString(item));
                        const id = item.getAttribute("id");
                        const lat = item.getAttribute("lat");
                        const lon = item.getAttribute("lon");
                        //console.log('id: ' + id + ', lat: ' + lat + ', lon: ' + lon + ' from ' + new XMLSerializer().serializeToString(item));
                        const tags = Array.from(item.getElementsByTagName("tag"));
                        for (const tag of tags) {
                            const k = tag.getAttribute("k");
                            const v = tag.getAttribute("v");
                            if (k in TAG_DICT) {
                                isQuestXML = true;
                                result += await translateTag2Html(changeset, k, v, lat, lon);
                                // We found a tag that we care about
                                // You can process it as needed
                            }
                        }
                    }            
                }

                if(!isQuestXML) {
                    throw new Error('not a quest changeset ' + changeset.id);
                }
            
                // snip the trailing <br /><br /> at the end
                if (result.length > 0) {
                    result = result.substring(0, result.length - 12);
                }

                return result;
            }

            async function generateTextFromChangeset(changeset) {
                const xml = await fetchChangesetXml(changeset.id);
                let result = await xml2text(changeset, xml);

                if (result.length === 0) {
                    throw new Error('empty changeset!');
                }

                return '<div class="comment">' + result + '</div>';
            }

            /**
            function computeChangesetDifference(xml1, xml2) {
                const parser = new DOMParser();
                const doc1 = parser.parseFromString(xml1, "text/xml");
                const doc2 = parser.parseFromString(xml2, "text/xml");

                const diff = {
                    added: [],
                    modified: [],
                    deleted: []
                };

                const elements1 = Array.from(doc1.getElementsByTagName("node"));
                const elements2 = Array.from(doc2.getElementsByTagName("node"));

                const map1 = new Map(elements1.map(el => [el.getAttribute("id"), el]));
                const map2 = new Map(elements2.map(el => [el.getAttribute("id"), el]));

                // Detect added and modified elements
                for (const [id, el2] of map2.entries()) {
                    if (!map1.has(id)) {
                        diff.added.push(el2);
                    } else if (el2.getAttribute("version") !== map1.get(id).getAttribute("version")) {
                        diff.modified.push(el2);
                    }
                }

                // Detect deleted elements
                for (const id of map1.keys()) {
                    if (!map2.has(id)) {
                        diff.deleted.push(map1.get(id));
                    }
                }

                return diff;
            }

            async function compareChangesets(changesetId1, changesetId2) {
                const xml1 = await fetchChangesetXml(changesetId1);
                const xml2 = await fetchChangesetXml(changesetId2);

                if (!xml1 || !xml2) {
                    alert("Failed to fetch one or both changesets.");
                    return;
                }

                const diff = computeChangesetDifference(xml1, xml2);

                console.log("Added nodes:", diff.added);
                console.log("Modified nodes:", diff.modified);
                console.log("Deleted nodes:", diff.deleted);

                alert(`Comparison complete:
                - Added: ${diff.added.length}
                - Modified: ${diff.modified.length}
                - Deleted: ${diff.deleted.length}`);
            }

            **/

            async function formatChangeset(changeset, changesetIndex) {
                const color = ( changesetIndex % 2 === 0 ) ? ' alt' : '';
                const textHtml = await generateTextFromChangeset(changeset);

                return `<li class="up"><div class="message-data">
                <span class="message-data-name">${changeset.user}</span></div>
                <div class="message${color}">
                ${textHtml}
                </div>
                </li>`;
            }

            document.addEventListener('DOMContentLoaded', function() {
                login();
            });
        </script>
    </body>
</html>